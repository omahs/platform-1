# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .rb file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the detils of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Ruby
# helpers directly inline like we're doing here.

require 'ffi'


module DashDriveV0
  def self.uniffi_in_range(i, type_name, min, max)
  raise TypeError, "no implicit conversion of #{i} into Integer" unless i.respond_to?(:to_int)
  i = i.to_int
  raise RangeError, "#{type_name} requires #{min} <= value < #{max}" unless (min <= i && i < max)
  i
end

def self.uniffi_utf8(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v = v.to_str.encode(Encoding::UTF_8)
  raise Encoding::InvalidByteSequenceError, "not a valid UTF-8 encoded string" unless v.valid_encoding?
  v
end

def self.uniffi_bytes(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v.to_str
end

  class RustBuffer < FFI::Struct
  layout :capacity, :int32,
         :len,      :int32,
         :data,     :pointer

  def self.alloc(size)
    return DashDriveV0.rust_call(:ffi_dash_drive_v0_rustbuffer_alloc, size)
  end

  def self.reserve(rbuf, additional)
    return DashDriveV0.rust_call(:ffi_dash_drive_v0_rustbuffer_reserve, rbuf, additional)
  end

  def free
    DashDriveV0.rust_call(:ffi_dash_drive_v0_rustbuffer_free, self)
  end

  def capacity
    self[:capacity]
  end

  def len
    self[:len]
  end

  def len=(value)
    self[:len] = value
  end

  def data
    self[:data]
  end

  def to_s
    "RustBuffer(capacity=#{capacity}, len=#{len}, data=#{data.read_bytes len})"
  end

  # The allocated buffer will be automatically freed if an error occurs, ensuring that
  # we don't accidentally leak it.
  def self.allocWithBuilder
    builder = RustBufferBuilder.new

    begin
      yield builder
    rescue => e
      builder.discard
      raise e
    end
  end

  # The RustBuffer will be freed once the context-manager exits, ensuring that we don't
  # leak it even if an error occurs.
  def consumeWithStream
    stream = RustBufferStream.new self

    yield stream

    raise RuntimeError, 'junk data left in buffer after consuming' if stream.remaining != 0
  ensure
    free
  end# The primitive String type.

  def self.allocFromString(value)
    RustBuffer.allocWithBuilder do |builder|
      builder.write value.encode('utf-8')
      return builder.finalize
    end
  end

  def consumeIntoString
    consumeWithStream do |stream|
      return stream.read(stream.remaining).force_encoding(Encoding::UTF_8)
    end
  end

  

  # The Sequence<T> type for u8.

  def self.alloc_from_Sequenceu8(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Sequenceu8(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceu8
    consumeWithStream do |stream|
      return stream.readSequenceu8
    end
  end

  
end

module UniFFILib
  class ForeignBytes < FFI::Struct
    layout :len,      :int32,
           :data,     :pointer

    def len
      self[:len]
    end

    def data
      self[:data]
    end

    def to_s
      "ForeignBytes(len=#{len}, data=#{data.read_bytes(len)})"
    end
  end
end

private_constant :UniFFILib
  
# Helper for structured reading of values from a RustBuffer.
class RustBufferStream

  def initialize(rbuf)
    @rbuf = rbuf
    @offset = 0
  end

  def remaining
    @rbuf.len - @offset
  end

  def read(size)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    data = @rbuf.data.get_bytes @offset, size

    @offset += size

    data
  end

  def readU8
    unpack_from 1, 'c'
  end

  def readString
    size = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative string length' if size.negative?

    read(size).force_encoding(Encoding::UTF_8)
  end

  

  

  # The Error type Error

  def readTypeError
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return Error::DriveError.new(
            readString()
        )
    end
    if variant == 2
        return Error::ProtocolError.new(
            readString()
        )
    end
    if variant == 3
        return Error::EmptyResponse.new
    end
    if variant == 4
        return Error::NoProof.new
    end
    if variant == 5
        return Error::DocumentMissingInProof.new
    end
    if variant == 6
        return Error::ProtoRequestDecodeError.new(
            readString()
        )
    end
    if variant == 7
        return Error::ProtoResponseDecodeError.new(
            readString()
        )
    end
    if variant == 8
        return Error::ProtoEncodeError.new(
            readString()
        )
    end

    raise InternalError, 'Unexpected variant tag for TypeError'
  end
  

  # The Sequence<T> type for u8.

  def readSequenceu8
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readU8
    end

    items
  end

  

  def unpack_from(size, format)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    value = @rbuf.data.get_bytes(@offset, size).unpack format

    @offset += size

    # TODO: verify this
    raise 'more than one element!!!' if value.size > 1

    value[0]
  end
end

private_constant :RustBufferStream
  
# Helper for structured writing of values into a RustBuffer.
class RustBufferBuilder
  def initialize
    @rust_buf = RustBuffer.alloc 16
    @rust_buf.len = 0
  end

  def finalize
    rbuf = @rust_buf

    @rust_buf = nil

    rbuf
  end

  def discard
    return if @rust_buf.nil?

    rbuf = finalize
    rbuf.free
  end

  def write(value)
    reserve(value.bytes.size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, value.bytes
    end
  end

  def write_U8(v)
    v = DashDriveV0::uniffi_in_range(v, "u8", 0, 2**8)
    pack_into(1, 'c', v)
  end

  def write_String(v)
    v = DashDriveV0::uniffi_utf8(v)
    pack_into 4, 'l>', v.bytes.size
    write v
  end

  

  # The Sequence<T> type for u8.

  def write_Sequenceu8(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_U8(item)
    end
  end

  

  private

  def reserve(num_bytes)
    if @rust_buf.len + num_bytes > @rust_buf.capacity
      @rust_buf = RustBuffer.reserve(@rust_buf, num_bytes)
    end

    yield

    @rust_buf.len += num_bytes
  end

  def pack_into(size, format, value)
    reserve(size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, [value].pack(format).bytes
    end
  end
end

private_constant :RustBufferBuilder

  # Error definitions
  class RustCallStatus < FFI::Struct
  layout :code,    :int8,
         :error_buf, RustBuffer

  def code
    self[:code]
  end

  def error_buf
    self[:error_buf]
  end

  def to_s
    "RustCallStatus(code=#{self[:code]})"
  end
end

# These match the values from the uniffi::rustcalls module
CALL_SUCCESS = 0
CALL_ERROR = 1
CALL_PANIC = 2


module Error
  class DriveError < StandardError
    def initialize(error)
        @error = error
        super()
      end

    attr_reader :error
    

    def to_s
     "#{self.class.name}(error=#{@error.inspect})"
    end
  end
  class ProtocolError < StandardError
    def initialize(error)
        @error = error
        super()
      end

    attr_reader :error
    

    def to_s
     "#{self.class.name}(error=#{@error.inspect})"
    end
  end
  class EmptyResponse < StandardError
    def initialize()
        super()
      end

    def to_s
     "#{self.class.name}()"
    end
  end
  class NoProof < StandardError
    def initialize()
        super()
      end

    def to_s
     "#{self.class.name}()"
    end
  end
  class DocumentMissingInProof < StandardError
    def initialize()
        super()
      end

    def to_s
     "#{self.class.name}()"
    end
  end
  class ProtoRequestDecodeError < StandardError
    def initialize(error)
        @error = error
        super()
      end

    attr_reader :error
    

    def to_s
     "#{self.class.name}(error=#{@error.inspect})"
    end
  end
  class ProtoResponseDecodeError < StandardError
    def initialize(error)
        @error = error
        super()
      end

    attr_reader :error
    

    def to_s
     "#{self.class.name}(error=#{@error.inspect})"
    end
  end
  class ProtoEncodeError < StandardError
    def initialize(error)
        @error = error
        super()
      end

    attr_reader :error
    

    def to_s
     "#{self.class.name}(error=#{@error.inspect})"
    end
  end

end


# Map error modules to the RustBuffer method name that reads them
ERROR_MODULE_TO_READER_METHOD = {

  Error => :readTypeError,

}

private_constant :ERROR_MODULE_TO_READER_METHOD, :CALL_SUCCESS, :CALL_ERROR, :CALL_PANIC,
                 :RustCallStatus

def self.consume_buffer_into_error(error_module, rust_buffer)
  rust_buffer.consumeWithStream do |stream|
    reader_method = ERROR_MODULE_TO_READER_METHOD[error_module]
    return stream.send(reader_method)
  end
end

class InternalError < StandardError
end

def self.rust_call(fn_name, *args)
  # Call a rust function
  rust_call_with_error(nil, fn_name, *args)
end

def self.rust_call_with_error(error_module, fn_name, *args)
  # Call a rust function and handle errors
  #
  # Use this when the rust function returns a Result<>.  error_module must be the error_module that corresponds to that Result.


  # Note: RustCallStatus.new zeroes out the struct, which is exactly what we
  # want to pass to Rust (code=0, error_buf=RustBuffer(len=0, capacity=0,
  # data=NULL))
  status = RustCallStatus.new
  args << status

  result = UniFFILib.public_send(fn_name, *args)

  case status.code
  when CALL_SUCCESS
    result
  when CALL_ERROR
    if error_module.nil?
      status.error_buf.free
      raise InternalError, "CALL_ERROR with no error_module set"
    else
      raise consume_buffer_into_error(error_module, status.error_buf)
    end
  when CALL_PANIC
    # When the rust code sees a panic, it tries to construct a RustBuffer
    # with the message.  But if that code panics, then it just sends back
    # an empty buffer.
    if status.error_buf.len > 0
      raise InternalError, status.error_buf.consumeIntoString()
    else
      raise InternalError, "Rust panic"
    end
  else
    raise InternalError, "Unknown call status: #{status.code}"
  end
end

private_class_method :consume_buffer_into_error

  # This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
module UniFFILib
  extend FFI::Library

  
  ffi_lib 'uniffi_dash_drive_v0'
  

  attach_function :uniffi_rs_drive_light_client_fn_func_hello,
    [RustCallStatus.by_ref],
    :void
  attach_function :uniffi_rs_drive_light_client_fn_func_identity_proof_to_cbor,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_dash_drive_v0_rustbuffer_alloc,
    [:int32, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_dash_drive_v0_rustbuffer_from_bytes,
    [ForeignBytes, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_dash_drive_v0_rustbuffer_free,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :ffi_dash_drive_v0_rustbuffer_reserve,
    [RustBuffer.by_value, :int32, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_rs_drive_light_client_checksum_func_hello,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_rs_drive_light_client_checksum_func_identity_proof_to_cbor,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :ffi_dash_drive_v0_uniffi_contract_version,
    [RustCallStatus.by_ref],
    :uint32
  
end

  # Public interface members begin here.

  
  

  
  

def self.hello()
  DashDriveV0.rust_call(:uniffi_rs_drive_light_client_fn_func_hello,)
end

  
  

def self.identity_proof_to_cbor(req_proto, resp_proto)
    req_proto = req_proto.map { |v| DashDriveV0::uniffi_in_range(v, "u8", 0, 2**8) }
    resp_proto = resp_proto.map { |v| DashDriveV0::uniffi_in_range(v, "u8", 0, 2**8) }
  result = DashDriveV0.rust_call_with_error(Error,:uniffi_rs_drive_light_client_fn_func_identity_proof_to_cbor,RustBuffer.alloc_from_Sequenceu8(req_proto),RustBuffer.alloc_from_Sequenceu8(resp_proto))
  return result.consumeIntoSequenceu8
end


  

  
end

